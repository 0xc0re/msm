#!/bin/bash

### BEGIN INIT INFO
# Provides:	  msm
# Required-Start: $local_fs $remote_fs
# Required-Stop:  $local_fs $remote_fs
# Should-Start:	  $network
# Should-Stop:	  $network
# Default-Start:  2 3 4 5
# Default-Stop:	  0 1 6
# Short-Description:	
# Description:	  
### END INIT INFO


# See http://www.debian.org/doc/debian-policy/ch-opersys.html#s-sysvinit for
# more information on debain init.d scripts, which may help you understand
# this script.


### Source the configuration file
source "/etc/msm.conf"

### Config variables the user should need/want to change

# Minecraft's whitelist file
declare -r WHITELIST="white-list.txt"
# Minecraft's banned ips file
declare -r BANNED_IPS="banned-ips.txt"
# Minecraft's banned players file
declare -r BANNED_PLAYERS="banned-players.txt"

# Jar group file which contains the download target URL
declare -r JARGROUP_TARGET="target.txt"
# Jar group directory name to download new jars to, is deleted afterwards
declare -r JARGROUP_DOWNLOAD_DIR="downloads"

# The flag which indicates the world should be put in RAM
declare -r WORLD_FLAG_INRAM="inram"
# The flag which indicates the server is active
declare -r SERVER_FLAG_ACTIVE="active"


### Script State Variables

# "true" whilst the script is counting down a delay to stop the server
declare STOP_COUNTDOWN

# "true" whilst the script is counting down a delay to restart the server
declare RESTART_COUNTDOWN


### Utility Functions

# Executes the command "$2" as user "$1"
# $1: The user to execute the command as
# $2: The command to execute
as_user() {
	if [ $(whoami) == $1 ]; then
		bash -c "$2"
	else
		su - $1 -s /bin/bash -c "$2"
	fi
}

# Executes the command "$1" as SERVER_USER but returns stderr instead
as_user_stderr() {
	as_user "$1" > /dev/null 2>&1
}

# Echo to stderr
echoerr() {
	echo "$@" 1>&2
}

# Determines whether "$1" is a valid name for a server or jar group directory
# It must only contain upper or lower case letters, digits, dashes or
# underscores.
# It must also not be one of a list of reserved names.
is_valid_name() {
	local valid="^[a-zA-Z0-9\_\-]+$"
	local invalid="^server|jargroup|start|stop|restart|all$"
	
	if [[ "$1" =~ $valid ]]; then
		if [[ "$1" =~ $invalid ]]; then
			echoerr "Invalid name \"$1\": A name may not be any of the following reserved worlds \"start\", \"stop\", \"restart\", \"server\", \"jargroup\" or \"all\"."
			return 1
		else
			return 0
		fi
	else
		echoerr "Invalid name \"$1\": A name may only contain letters, numbers, dashes and unscores."
		return 1
	fi
}

# Gets the latest jar from a jar group, based upon the date and time encoded
# in the file name.
get_latest_file() {
	local best_time=0
	local best_file=""
	
	for file in "$1/*"; do
		# Remove the path, leaving just the file name
		local name=$(basename "$file")
		
		local date_time=$(echo $name | awk -F '-' '{print $1 "-" $2 "-" $3 " " $4 ":" $5 ":" $6}')
		
		# Get the time in seconds since 1970 from file name
		local seconds=$(date -d "$date_time" "+%s" 2> /dev/null)
		
		# If that is newer than the current best, override variables
		if [[ $seconds > $best_time ]]; then
			best_time=$seconds
			best_file=$file
		fi
	done
	
	echo $best_file
}

# Returns the current time as a UNIX timestamp (in seconds since 1970)
now() {
	date +%s
}


### Log Utility Functions

# Gets the UNIX timestamp for a server log line
# $1: A server log line
# returns: Time in seconds since 1970-01-01 00:00:00 UTC
log_line_get_time() {
	time_string=$(echo $1 | awk '{print $1 " " $2}')
	date -d "$time_string" "+%s" 2> /dev/null
}


### World Utility Functions

# Moves a world to RAM
# $1: the ID of the world to move
world_to_ram() {
	if [ ! -z $RAMDISK_STORAGE_PATH ]; then
		as_user ${server_user_name[${world_server_id[$1]}]} "mkdir -p ${world_ramdisk_path[$1]} && rsync -rt --exclude '$WORLD_FLAG_INRAM' \"${world_path[$1]}/\" \"${world_ramdisk_path[$1]}\""
	fi
}

# Moves a world in RAM to disk
# $1: the ID of the world to move
world_to_disk() {
	as_user ${server_user_name[${world_server_id[$1]}]} "rsync -rt --exclude '$WORLD_FLAG_INRAM' \"${world_ramdisk_path[$1]}/\" \"${world_path[$1]}\""
}

# Toggles a worlds ramdisk state
# $1: The ID of the world
world_toggle_ramdisk_state() {
	if [ -e ${world_flag_inram[$1]} ]; then
		echo -n "Removing RAM flag from world \"${world_name[$1]}\"... "
		as_user ${server_user_name[${world_server_id[$1]}]} "rm -f \"${world_flag_inram[$1]}\""
		echo "Done."
		
		echo -n "Removing world \"${world_name[$1]}\" from RAM... "
		as_user ${server_user_name[${world_server_id[$1]}]} "rm -r \"${world_ramdisk_path[$1]}\""
		echo "Done."
	else
		echo -n "Adding RAM flag to world \"${world_name[$1]}\"... "
		as_user ${server_user_name[${world_server_id[$1]}]} "touch \"${world_flag_inram[$1]}\""
		echo "Done."
		
		echo -n "Copying world to RAM... "
		world_to_ram $1
		echo "Done."
	fi
	echo "Changes will only take effect after server is restarted."	
}


### Server Utility Functions

# Returns the ID for a server.
# An ID is given to a server when loaded into memory, and can be used to lookup
# config information for that server
# $1: The name of the server
server_get_id() {
	local i=0
	while [[ $i < $num_servers ]]; do
		if [[ "${server_name[$i]}" == "$1" ]]; then
			echo "$i"
			return 0
		fi
		
		i=$(( $i + 1 ))
	done
	
	return 1
}

# Returns the ID of a server's world.
# $1: The ID of the server
# $2: The name of the world
server_world_get_id() {
	local i=${server_world_offset[$1]}
	local max=$(( $i + ${server_num_worlds[$1]} ))
	
	# For each of the servers worlds:
	while [[ $i < $max ]]; do
		if [[ "${world_name[$i]}" == "$2" ]]; then
			echo $i
			return 0
		fi
		
		i=$(( $i + 1 ))
	done
	
	return 1
}

# Returns 0 if the server $1 is running and 1 if not
# $1: The name of server
server_is_running() {
	local id=$(server_get_id "$1")
	
	if ps ax | grep -v grep | grep "${server_screen_name[$1]} ${server_invocation[$1]}" > /dev/null
	then
		return 0
	else
		return 1
	fi
}

# Creates symbolic links in the server directory (SERVER_STORAGE_PATH) for each
# of the Minecraft worlds located in the world storage directory.
# $1: The id of the server for which links should be ensured
server_ensure_links() {
	echo -n "Maintaining world symbolic links... "
	local i=${server_world_offset[$1]}
	local max=$(( $i + ${server_num_worlds[$1]} ))
	
	while [[ $i < $max ]]; do
		# -L checks for the path being a link rather than a file
		# ! -a, since it is within double square brackets means: the negation of
		# the existence of the file. In other words: true if does not exist
		if [[ -L "${world_link[$i]}" || ! -a "${world_link[$i]}" ]]; then
			# If there is a symbolic link in the server direcotry to this world,
			# or there is not a directory in the server directory containing this world.
			
			# Get the original file path the symbolic link is pointing to
			# If there is no link, link_target will contain nothing
			link_target=$(readlink "${world_link[$i]}")
			
			if ${world_inram[$i]}; then
				# If this world is marked as loaded into RAM

				if [ "${link_target}" != "${world_ramdisk_path[$i]}" ]; then
					# If the symbolic link does not point to the RAM version of the world

					# Remove the symbolic link if it exists
					as_user ${server_user_name[$1]} "rm -f \"${world_link[$i]}\""

					# Create a new symbolic link pointing to the RAM version of the world
					as_user ${server_user_name[$1]} "ln -s \"${world_ramdisk_path[$i]}\" \"${world_link[$i]}\""
				fi
			else
				# Otherwise the world is not loaded into RAM, and is just on disk

				if [ "${link_target}" != "${world_path[$i]}" ]; then
					# If the symbolic link does not point to the disk version of the world

					# Remove the symbolic link if it exists
					as_user ${server_user_name[$1]} "rm -f \"${world_link[$i]}\""

					# Create a new symbolic link pointing to the disk version of the world
					as_user ${server_user_name[$1]} "ln -s \"${world_path[$i]}\" \"${world_link[$i]}\""
				fi
			fi
		fi
		
		i=$(( $i + 1 ))
	done
	
	echo "Done."
}

# Moves a servers worlds into RAM
# $1: The ID of the server
server_worlds_to_ram() {
	# Only proceed if there is a ramdisk path set in config
	if [ ! -z $RAMDISK_STORAGE_PATH ]; then
		echo -n "Synchronising flagged worlds on disk to RAM... "
		local i=${server_world_offset[$1]}
		local max=$(( $i + ${server_num_worlds[$1]} ))
		
		# For each of the servers worlds:
		while [[ $i < $max ]]; do
			if ${world_inram[$i]} && [ -L ${world_link[$i]} ]; then
				world_to_ram $i
			fi
			
			i=$(( $i + 1 ))
		done
		echo "Done."
	fi
}

# Moves a servers "in RAM" worlds back to disk
# $1: The ID of the server
server_worlds_to_disk() {
	if [ ! -z $RAMDISK_STORAGE_PATH ]; then
		echo -n "Synchronising worlds in RAM to disk... "
		local i=${server_world_offset[$1]}
		local max=$(( $i + ${server_num_worlds[$1]} ))
		
		# For each of the servers worlds:
		while [[ $i < $max ]]; do
			if [ -e ${world_ramdisk_path[$i]} ]; then
				world_to_disk $i		
			fi
			
			i=$(( $i + 1 ))
		done
		echo "Done."
	fi
}

# Watches the a server's log
# $1: The ID for the server
# $2: The line in the log to wait for
# $3: A UNIX timestamp (seconds since 1970) which the $2 line must be after
# returns: When the line is found
server_log_get_line() {
    # Make sure there is a server log to check
    as_user ${server_user_name[$1]} "touch ${server_log[$1]}"

	regex="^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2} \[.*\] ${2}"

	while read line
	do
		line_time=$(log_line_get_time "$line")

		# If the entry is old enough and matches the regular expression
		if [[ $line_time -ge $3 && $line =~ $regex ]]
		then
			echo $line
			break
		fi
	done < <(as_user ${server_user_name[$1]} "tail --follow --lines=100 --sleep-interval=0.1 ${server_log[$1]}")
}

# The same as server_log_get_line, but does not print the line to stdout
# when found.
server_log_wait_for_line() {
	server_log_get_line $1 $2 $3 > /dev/null
}

# Sends as string to a server for execution
# $1: The ID of the server
# $2: The line of text to enter into the server console
server_eval() {
	as_user ${server_user_name[$1]} "screen -p 0 -S ${server_screen_name[$1]} -X eval 'stuff \"$2\"\015'"
}

# The same as server_eval, but also waits for a log entry before returning
# $1: The ID of the server
# $2: A line of text to enter into the server console
# $3: The line of text in the log to wait for
# stdout: The full entry found in the logs
server_eval_and_get_line() {
	time_now=$(now)
	server_eval $1 "$2"
	server_log_get_line $1 "$3" "$time_now"
}

# The same as server_eval_and_get_line, but does not print anything to stdout
server_eval_and_wait() {
	server_eval_and_get_line $1 "$2" "$3" > /dev/null
}

# Gets the process ID for a server if running, otherwise it outputs nothing
# $1: The ID of the server
server_pid() {
	ps ax | grep -v grep | grep "${server_screen_name[$1]} ${server_invocation[$1]}" | awk '{print $1}'
}

# Waits for a server to stop by polling 10 times a second
# This approach is fairyl intensive, so only use when you are expecting the
# server to stop soon
# $1: The ID of the server to wait for
server_wait_for_stop() {
	local pid=$(server_pid $1)

	while ps -p $pid > /dev/null; do
		sleep 0.1
	done
}

# Sets a server's active/inactive state
# $1: The ID of the server
# $2: A string containing "active" or "inactive"
server_set_active() {
	case "$2" in
		active)
			as_user ${server_user_name[$1]} "touch ${server_flag_active[$1]}"
			server_active[$1]="true"
			;;
		inactive)
			as_user ${server_user_name[$1]} "rm -f ${server_flag_active[$1]}"
			server_active[$1]="false"
			;;
		*)
			return 1
			;;
	esac
}


### Jar Group Functions

# Lists the jar files grouped by jar groups.
jargroup_list() {
	for group in $(ls -1 "$JAR_STORAGE_PATH"); do
		echo "${group}:"
		for jar in $(ls -1r $JAR_STORAGE_PATH/$group); do
			if [[ "$jar" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}- ]]; then
				echo "    $jar"
			fi
		done
	done
}

# Creates a new jargroup
# $1: The name for the jargroup
jargroup_create() {
	if is_valid_name "$1"; then
		if [[ ! -e "$JAR_STORAGE_PATH/$1" ]]; then
			printf "Creating jar group... "
			
			local error=$(as_user_stderr "mkdir -p '$JAR_STORAGE_PATH/$1'")
			if [[ "$error" != "" ]]; then
				echo "Failed."
				echo "Reason: $error"
				return 1
			fi
			
			error=$(as_user "echo \"$2\" > '$JAR_STORAGE_PATH/$1/$JARGROUP_TARGET'")
			if [[ "$error" != "" ]]; then
				echo "Failed."
				echo "Reason: $error"
				return 1
			fi
			
			echo "Done."
			
			# Download the latest version now
			jargroup_getlatest "$1"
		else
			echo "A jar group with that name already exists."
			return 1
		fi
	else
		return 1
	fi
}

# Downloads the latest version for a jargroup, using the target URL for that
# group. Saves the download with the date and time encoded in the start of the
# file name, in the jar group directory in question. Removes the file if there
# is no difference between it and the current version.
# $1: The jargroup name to download the latest version for
jargroup_getlatest() {
	if is_valid_name "$1"; then
		if [[ -e "$JAR_STORAGE_PATH/$1" ]]; then
			if [[ -e "$JAR_STORAGE_PATH/$1/$JARGROUP_TARGET" ]]; then
				printf "Downloading latest version... "
			
				# Try and make 
				local error=$(as_user_stderr "mkdir -p '$JAR_STORAGE_PATH/$1/$JARGROUP_DOWNLOAD_DIR'")
				if [[ "$error" != "" ]]; then
					echo "Failed."
					echo "Reason: $error"
					return 1
				fi
			
				as_user "wget --quiet --input-file='$JAR_STORAGE_PATH/$1/$JARGROUP_TARGET' --directory-prefix='$JAR_STORAGE_PATH/$1/$JARGROUP_DOWNLOAD_DIR' --no-check-certificate"
				echo "Done."
			
				local num_files=$(as_user "ls -1 '$JAR_STORAGE_PATH/$1/$JARGROUP_DOWNLOAD_DIR' | wc -l")
			
				if [[ $num_files == 1 ]]; then
					# There was 1 file downloaded
				
					local file_name=$(ls -1 "$JAR_STORAGE_PATH/$1/$JARGROUP_DOWNLOAD_DIR")
					local new_name="$(date +%F-%H-%M-%S)-$file_name"
					local most_recent_jar=$(get_latest_file "$JAR_STORAGE_PATH/$1")
				
					if [[ ! -e "$most_recent_jar" ]] || ! diff "$most_recent_jar" "$JAR_STORAGE_PATH/$1/$JARGROUP_DOWNLOAD_DIR/$file_name"; then
						# There is not a previous version to do a comparison against, or
						# The previous version is different:
						# Add it to the group
					
						[[ -e "$most_recent_jar" ]]
						local was_previous=$?
					
						as_user "mv '$JAR_STORAGE_PATH/$1/$JARGROUP_DOWNLOAD_DIR/$file_name' '$JAR_STORAGE_PATH/$1/$new_name'"
					
						if [[ $was_previous == 0 ]]; then
							echo "Downloaded version was different to previous latest. Saved as \"$1/$new_name\"."
						else
							echo "Saved as \"$JAR_STORAGE_PATH/$1/$new_name\"."
						fi
					else
						echo "Existing version \"$JAR_STORAGE_PATH/$1/$new_name\" was already up to date."
					fi
				
				elif [[ $num_files == 0 ]]; then
					# No file was downloaded
					echo "Failed. No files were downloaded."
				else
					# Multiple files were
					echo "Error. URL downloads multiple files."
				fi
			
				# Clean up the temp download folder
				as_user "rm -fr '$JAR_STORAGE_PATH/$1/$JARGROUP_DOWNLOAD_DIR'"
			else
				echo "Target URL not found, use $0 jargroup seturl <download-url>"
				return 1
			fi
		else
			echo "There is no jar group with the name \"$1\"."
			return 1
		fi
	else
		return 1
	fi
}

# Deletes an existing jargroup
# $1: The name of the existing jargroup
jargroup_delete() {
	if is_valid_name "$1"; then
		if [[ -e "$JAR_STORAGE_PATH/$1" ]]; then
			printf "Are you sure you want to delete this jar group [y/N]: "
		
			read answer
			if [[ "$answer" =~ ^y|Y|yes$ ]]; then
				as_user "rm -rf $JAR_STORAGE_PATH/$1"
				echo "Jar group deleted."
			else
				echo "Jar group was NOT deleted."
			fi
		else
			echo "There is no jar group with the name \"$1\"."
			return 1
		fi
	else
		return 1
	fi
}

# Renames an existing jargroup
# $1: The name of the existing jargroup
# $2: The new name
jargroup_rename() {
	if is_valid_name "$1"; then
		if [[ -e "$JAR_STORAGE_PATH/$1" ]]; then
			# If the jar group name is valid,
			# and there is no other jar group with the name $1
		
			if is_valid_name "$2"; then
				if [[ -e "$JAR_STORAGE_PATH/$2" ]]; then
					echo "Could not be renamed, there is already a jar group with the name \"$2\"."
					return 1
				else
					# TODO: Update any symbolic links which point to a jar in this directory
					as_user "mv '$JAR_STORAGE_PATH/$1' '$JAR_STORAGE_PATH/$2'"
					echo "Renamed jar group \"$1\" to \"$2\"."
				fi
			else
				return 1
			fi
		else
			echo "There is no jar group with the name \"$1\"."
			return 1
		fi
	else
		return 1
	fi
}


### Server Functions

# Echos a list of servers in the SERVER_STORAGE_PATH
server_list() {
	echo "Servers:"
	for server in "$SERVER_STORAGE_PATH/*"; do
		echo "  $(basename $server)"
	done
}

# Creates a new server
# $1: The server name to create
server_create() {
	if is_valid_name "$1"; then
		if [[ -e "$SERVER_STORAGE_PATH/$1" ]]; then
			echo "A server with that name already exists."
			return 1
		else
			printf "Creating server directory... "
			as_user "mkdir -p '$SERVER_STORAGE_PATH/$1'"
			as_user "touch '$SERVER_STORAGE_PATH/$1/$WHITELIST'"
			as_user "touch '$SERVER_STORAGE_PATH/$1/$BANNED_IPS'"
			as_user "touch '$SERVER_STORAGE_PATH/$1/$BANNED_PLAYERS'"
			echo "Done."
		fi
	else
		return 1
	fi
}

# Deletes an existing server
# $2: The server name to delete
server_delete() {
	if is_valid_name "$1"; then
		if [[ -e "$SERVER_STORAGE_PATH/$1" ]]; then
			printf "Are you sure you want to delete this server and its worlds (note: backups are preserved) [y/N]: "

			read answer
			if [[ "$answer" =~ ^y|Y|yes$ ]]; then
				# TODO: stop the server if running first
				as_user "rm -rf '$SERVER_STORAGE_PATH/$1'"
				echo "Server deleted."
			else
				echo "Server was NOT deleted."
			fi
		else
			echo "There is no server with the name \"$1\"."
			return 1
		fi
	else
		return 1
	fi
}

# Renames an existing server
# $1: The server name to change
# $2: The new name for the server
server_rename() {
	if is_valid_name "$1"; then
		if [[ -e "$SERVER_STORAGE_PATH/$1" ]]; then
			# If the server name is valid and exists
		
			# TODO: Check that the server is not running first, return if it is
		
			if is_valid_name "$2"; then
				# If the server name is valid
				if [[ -e "$SERVER_STORAGE_PATH/$2" ]]; then
					# and there is not already a server with the name $2
					echo "Could not be renamed, there is already a server with the name \"$2\"."
					return 1
				else
					as_user "mv '$SERVER_STORAGE_PATH/$1' '$SERVER_STORAGE_PATH/$2'"
					echo "Renamed server \"$1\" to \"$2\"."
				fi
			else
				return 1
			fi
		else
			echo "There is no server with the name \"$1\"."
			return 1
		fi
	else
		return 1
	fi
}

# Starts a single server
# $1: The ID of the server
server_start() {
	if server_is_running $1; then
		echo "Server \"${server_name[$1]}\" is already running!"
	else
		server_ensure_links $1
		server_worlds_to_ram $1

		local time_now=$(now)
		
		printf "Starting server... "
		
		server_set_active $1 "active"
		as_user ${server_user_name[$1]} "cd ${server_path[$1]} && screen -dmS ${server_screen_name[$1]} ${server_invocation[$1]}"
		server_log_wait_for_line $1 "${server_confirm_start[$1]}" "$time_now"
		
		echo "Done."
	fi
}

# Sends the "save-all" command to a server
# $1: The ID of the server
server_save_all() {
	if server_is_running $1; then
		# Send the "save-all" command and wait for it to finish
		printf "Forcing save... "
		
		server_eval_and_wait $1 "save-all" "${server_confirm_save_all[$1]}"
		
		echo "Done."
	else
		echo "Server \"${server_name[$1]}\" was not running."
	fi
}

# Stops a single server
# $1: The ID of the server
server_stop() {
    if server_is_running $1; then
		server_save_all $1
		
		printf "Stopping the server... "
		
		server_set_active $1 "inactive"
		server_eval $1 "stop"
		STOP_COUNTDOWN[$1]="false"
		RESTART_COUNTDOWN[$1]="false"
		server_wait_for_stop $1
		
		echo "Done."
		
		# Synchronise all worlds in RAM to disk
		server_worlds_to_disk $1
	else
		echo "Server \"${server_name[$1]}\" was not running."
	fi
}

# Restarts a single server
# $1: The ID of the server 
server_restart() {
	# Restarts the server if it is already running
	if server_is_running $1; then
		server_stop $1
	fi
	
	server_start $1
}

# List the worlds available for a server
# $1: The ID of the server
server_worlds_list() {
	for ((i=${server_world_offset[$1]}; i<${server_num_worlds[$1]}; i++)); do
		if ${world_inram[$i]}; then
			echo "[RAM] ${world_name[$i]}"
		else
			echo "[DSK] ${world_name[$i]}"
		fi
	done
}


### Main Functions

init() {
	local i=0
	local j=0
	
	for server in $(ls -1 "$SERVER_STORAGE_PATH"); do
		server_name[$i]="$server"
		server_path[$i]="$SERVER_STORAGE_PATH/$server"
		server_conf[$i]="${server_path[$i]}/$DEFAULT_SERVER_CONF"
		server_flag_active[$i]="${server_path[$i]}/$SERVER_FLAG_ACTIVE"
		
		if [[ -e "${server_flag_active[$i]}" ]]; then
			server_active[$i]="true"
		else
			server_active[$i]="false"
		fi
		
		# Setup defaults
		# Note: screen_name will at this stage have the {SERVER_NAME} tag in it
		# which needs to be replaced.
		# Invocation may also the {RAM} and {JAR} tags.
		
		server_user_name[$i]="$DEFAULT_SERVER_USER"
		server_screen_name[$i]="${DEFAULT_SCREEN_NAME//\{SERVER_NAME\}/${server_name[$i]}}" # Replace tags now, they cannot change
		server_world_storage[$i]="${server_path[$i]}/$DEFAULT_WORLD_STORAGE_PATH"
		server_log[$i]="${server_path[$i]}/$DEFAULT_LOG"
		server_jar[$i]="${server_path[$i]}/$DEFAULT_JAR"
		server_ram[$i]="$DEFAULT_RAM"
		server_invocation[$i]="$DEFAULT_INVOCATION" # Don't replace tags yet, they may change
		server_stop_delay[$i]="$DEFAULT_STOP_DELAY"
		server_restart_delay[$i]="$DEFAULT_RESTART_DELAY"
		server_stop_message[$i]="$DEFAULT_STOP_MESSAGE"
		server_stop_abort[$i]="$DEFAULT_STOP_ABORT"
		server_restart_message[$i]="$DEFAULT_RESTART_MESSAGE"
		server_restart_abort[$i]="$DEFAULT_RESTART_ABORT"
		server_world_backup_started[$i]="$DEFAULT_WORLD_BACKUP_STARTED"
		server_world_backup_finished[$i]="$DEFAULT_WORLD_BACKUP_FINISHED"
		server_complete_backup_started[$i]="$DEFAULT_COMPLETE_BACKUP_STARTED"
		server_complete_backup_finished[$i]="$DEFAULT_COMPLETE_BACKUP_FINISHED"
		server_confirm_save_on[$i]="$DEFAULT_CONFIRM_SAVE_ON"
		server_confirm_save_off[$i]="$DEFAULT_CONFIRM_SAVE_OFF"
		server_confirm_save_all[$i]="$DEFAULT_CONFIRM_SAVE_ALL"
		server_confirm_start[$i]="$DEFAULT_CONFIRM_START"
		
		
		# Load config overrides from server config file if present
		
		if [[ -e "${server_conf[$i]}" ]]; then
			local name
			local value
			
			while read line; do 
			 	# ignore comment lines
				echo "$line" | grep "^#" >/dev/null 2>&1 && continue
			
			   	# if not empty, set the property using declare
			   	if [ ! -z "$line" ]; then
				 	name="$(echo $line | awk -F '=' '{print $1}')"
					value="$(echo $line | awk -F '\"' '{print $2}')"
				fi
				
				case "$name" in
					SERVER_USER) server_user_name[$i]="$value";;
					SCREEN_NAME) server_screen_name[$i]="$value";;
					WORLD_STORAGE_DIR) server_world_storage[$i]="${server_path[$i]}/$value";;
					LOG) server_log[$i]="${server_path[$i]}/$value";;
					JAR) server_jar[$i]="${server_path[$i]}/$value";;
					RAM) server_ram[$i]="$value";;
					INVOCATION) server_invocation[$i]="$value";;
					STOP_DELAY) server_stop_delay[$i]="$value";;
					RESTART_DELAY) server_restart_delay[$i]="$value";;
					STOP_MESSAGE) server_stop_message[$i]="$value";;
					STOP_ABORT) server_stop_abort[$i]="$value";;
					RESTART_MESSAGE) server_restart_message[$i]="$value";;
					RESTART_ABORT) server_restart_abort[$i]="$value";;
					WORLD_BACKUP_STARTED) server_world_backup_started[$i]="$value";;
					WORLD_BACKUP_FINISHED) server_world_backup_finished[$i]="$value";;
					COMPLETE_BACKUP_STARTED) server_complete_backup_started[$i]="$value";;
					COMPLETE_BACKUP_FINISHED) server_complete_backup_finished[$i]="$value";;
					CONFIRM_SAVE_ON) server_confirm_save_on[$i]="$value";;
					CONFIRM_SAVE_OFF) server_confirm_save_off[$i]="$value";;
					CONFIRM_SAVE_ALL) server_confrim_save_all[$i]="$value";;
					CONFIRM_START) server_confrim_start[$i]="$value";;
				esac
			done < "${server_conf[$i]}"
		fi
		
		# Replace tags in delay messages
		server_stop_message[$i]="${server_stop_message[$i]//\{DELAY\}/${server_stop_delay[$i]}}"
		server_restart_message[$i]="${server_restart_message[$i]//\{DELAY\}/${server_restart_delay[$i]}}"
		
		# Replace tags in server invocation
		server_invocation[$i]="${server_invocation[$i]//\{RAM\}/${server_ram[$i]}}"
		server_invocation[$i]="${server_invocation[$i]//\{JAR\}/${server_jar[$i]}}"
		
		
		# Load worlds if there is a world storage directory present
		server_world_offset[$i]=0
		server_num_worlds[$i]=0
		
		if [[ -e "${server_world_storage[$i]}" ]]; then
			server_worlds[$i]=$(ls -1 "${server_world_storage[$i]}")
			
			# Record the index at which worlds for this server start
			server_world_offset[$i]=$j
		
			for world in ${server_worlds[$i]}; do
				world_server_id[$j]="$i"
				world_name[$j]="$world"
				world_path[$j]="${server_world_storage[$i]}/${world_name[$j]}"
				world_link[$j]="${server_path[$i]}/${world_name[$j]}"
				world_flag_inram[$j]="${world_path[$j]}/$WORLD_FLAG_INRAM"
				
				if [ ! -z $RAMDISK_STORAGE_PATH ]; then
					world_ramdisk_path[$j]="${RAMDISK_STORAGE_PATH}/${server_name[$i]}/${world_name[$j]}"
				fi
			
				if [[ -e "${world_path[$j]}/$WORLD_FLAG_INRAM" ]]; then
					world_inram[$j]="true"
				else
					world_inram[$j]="false"
				fi
				
				### Printout
				# echo "World server: ${server_name[${world_server_id[$j]}]}"
				# echo "World ID: $j"
				# echo "World name: ${world_name[$j]}"
				# echo "World path: ${world_path[$j]}"
				# echo "World link: ${world_link[$j]}"
				# echo "World flag inram: ${world_flag_inram[$j]}"
				# echo "World ramdisk path: ${world_ramdisk_path[$j]}"
				# echo "World inram: ${world_inram[$j]}"
			
				j=$(($j+1))
			done
			
			# Record the number of worlds this server has
			server_num_worlds[$i]=$(( $j - ${server_world_offset[$i]} ))
		fi

		### Printout
		# echo "Name: ${server_name[$i]}"
		# echo "Path: ${server_path[$i]}"
		# echo "Conf: ${server_conf[$i]}"
		# echo "Active: ${server_active[$i]}"
		# echo "User name: ${server_user_name[$i]}"
		# echo "Screen name: ${server_screen_name[$i]}"
		# echo "World storage: ${server_world_storage[$i]}"
		# echo "Log: ${server_log[$i]}"
		# echo "Jar: ${server_jar[$i]}"
		# echo "Ram: ${server_ram[$i]}"
		# echo "Invocation: ${server_invocation[$i]}"
		# echo "Stop delay: ${server_stop_delay[$i]}"
		# echo "Restart delay: ${server_restart_delay[$i]}"
		# echo "Stop message: ${server_stop_message[$i]}"
		# echo "Restart message: ${server_restart_message[$i]}"
		# echo "World backup started: ${server_world_backup_started[$i]}"
		# echo "World backup finished: ${server_world_backup_finished[$i]}"
		# echo "World backup started: ${server_complete_backup_started[$i]}"
		# echo "World backup finished: ${server_complete_backup_finished[$i]}"
		# echo "Confirm save-on: ${server_confirm_save_on[$i]}"
		# echo "Confirm save-off: ${server_confirm_save_off[$i]}"
		# echo "Confirm save-all: ${server_confirm_save_all[$i]}"
		# echo "Confirm start: ${server_confirm_start[$i]}"
		# echo -n "Worlds: "
		# for world in ${server_worlds[$i]}; do
		# 	echo -n "$world, "
		# done
		# echo
		# echo
		
		i=$(($i+1))
	done
	
	num_servers=$i
	num_worlds=$j
}

# Called if the script is interrupted before exiting naturally
interrupt() {
	for ((i=0; $i<$num_servers; i++)); do
		if [[ "${STOP_COUNTDOWN[$i]}" ]] && server_is_running $i; then
			server_eval $i "say ${server_stop_abort[$i]}"
			echo
			echo "Broadcast the message \"${server_stop_abort[$id]}\" to players."
		fi
		if [[ "${RESTART_COUNTDOWN[$i]}" ]] && server_is_running $i; then
			server_eval $i "say ${server_restart_abort[$i]}"
			echo
			echo "Broadcast the message \"${server_restart_abort[$id]}\" to players."
		fi
	done
	exit
}

# The main function which starts the script
main() {
	# Initialise variables that represent system state
	init
	
	# Trap interrupts to the script by calling the interrupt function
	trap interrupt EXIT
	
	case "$1" in
		start)
			# Required start option, for debian init.d scripts
			;;
		stop)
			# Required stop option, for debian init.d scripts
			;;
		restart)
			# Required restart option, for debian init.d scripts
			;;
		server)
			case "$2" in
				list)
					# Lists the existing servers
					server_list
					;;
				create)
					if [ -z "$3" ]; then
						# If a server name is not provided
						echo "Invalid command."
					else
						# Create a new server
						server_create "$3"
					fi
					;;
				delete)
					if [ -z "$3" ]; then
						# If a server name is not provided
						echo "Invalid command."
					else
						# Delete an existing server, with confirmation
						server_delete "$3"
					fi
					;;
				rename)
					if [ -z "$3" ] || [ -z "$4" ]; then
						# If a server name is not provided
						echo "Invalid command."
					else
						# Rename an existing server
						server_rename "$3" "$4"
					fi
					;;
				*)
					# "server" is not a valid command
					echo "Invalid command."
					;;
			esac
			;;
		jargroup)
			case "$2" in
				list)
					# Lists the jars grouped by jargroup
					jargroup_list
					;;
				create)
					if [ -z "$3" ] || [ -z "$4" ]; then
						echo "Invlaid command."
					else
						jargroup_create "$3" "$4"
					fi
					;;
				delete)
					if [ -z "$3" ]; then
						echo "Invalid command."
					else
						jargroup_delete "$3"
					fi

					;;
				rename)
					if [ -z "$3" ] || [ -z "$4" ]; then
						echo "Invalid command."
					else
						jargroup_rename $3 $4
					fi
					;;
				changetarget)
					if [ -z "$3" ] || [ -z "$4" ]; then
						echo "Invalid command."
					else
						jargroup_settarget "$3" "$4"
					fi
					;;
				getlatest)
					if [ -z "$3" ]; then
						echo "Invalid command."
					else
						jargroup_getlatest "$3"
					fi
					;;
				*)
					# "jargroup" is not a valid command
					echo "Invalid command."
					;;
			esac
			;;
		help)
			# Outputs a list of all commands
			echo -e "Usage: $0 command:"
			echo -e
			echo -e "--Setup Commands------------------------------------------------"
			echo -e "  server list \t\t\t\t\tList servers"
			echo -e "  server create <name> \t\t\t\tCreates a new Minecraft server"
			echo -e "  server delete <name> \t\t\t\tDeletes an existing Minecraft server"
			echo -e "  server rename <name> <new-name> \t\tRenames an existing Minecraft server"
			echo -e
			echo -e "--Server Mangement Commands-------------------------------------"
			echo -e "  <server> start \t\t\t\tStarts a server"
			echo -e "  <server> stop [now] \t\t\t\tStops a server after warning players, or right now"
			echo -e "  <server> restart [now] \t\t\tRestarts a server after warning players, or right now"
			echo -e "  <server> status \t\t\t\tShow the running/stopped status of a server"
			echo -e "  <server> connected \t\t\t\tList a servers connected players"
			echo -e "  <server> worlds list \t\t\t\tLists the worlds a server has"
			echo -e "  <server> worlds load \t\t\t\tCreates links to worlds in storage for a server"
			echo -e "  <server> worlds ram <world> \t\t\tToggles a world's \"in RAM\" status"
			echo -e "  <server> worlds toram \t\t\tSynchronises any RAM enabled worlds to RAM a server has"
			echo -e "  <server> worlds todisk \t\t\tSynchronises any \"in RAM\" worlds to disk a server has"
			echo -e "  <server> worlds backup \t\t\tMakes a backup of all worlds a server has"
			echo -e "  <server> logroll \t\t\t\tMove a server log to a gziped archive, to reduce lag"
			echo -e "  <server> backup \t\t\t\tMakes a backup of an entire server directory"
			echo -e
			echo -e "--Server Pass Through Commands----------------------------------"
			echo -e "  <server> wl on|off <player> \t\t\tEnabled/disable server whitelist check"
			echo -e "  <server> wl add|remove <player> \t\tAdd/remove a player to/from a server's whitelist"
			echo -e "  <server> wl list \t\t\t\tList the players whitelisted for a server"
			echo -e "  <server> bl player add|remove <player> \tBan/pardon a player from/for a server"
			echo -e "  <server> bl ip add|remove <ip address> \tBan/pardon an IP address from/for a server"
			echo -e "  <server> bl list \t\t\t\tLists the banned players and IP address for a server"
			echo -e "  <server> op add|remove <player> \t\tAdd/remove operator status for a player on a server"
			echo -e "  <server> gm survival|creative <player> \tChange the game mode for a player on a server"
			echo -e "  <server> kick <player> \t\t\tForcibly disconnect a player from a server"
			echo -e "  <server> say <message> \t\t\tBroadcast a (pink) message to all players on a server"
			echo -e "  <server> time set|add <number> \t\tSet/increment time on a server (0-24000)"
			echo -e "  <server> toggledownfall \t\t\tToggles rain and snow on a server"
			echo -e "  <server> save on|off \t\t\t\tEnable/disable writing world changes to file"
			echo -e "  <server> save all \t\t\t\tForce the writing of all non-saved world changes to file"
			echo -e "  <server> cmd <command> \t\t\tSend a command string to the server and return"
			echo -e "  <server> cmdlog <command> \t\t\tSame as 'cmd' but shows log output afterwards (Ctrl+C to exit)"
			echo -e
			echo -e "--Jar Commands--------------------------------------------------"
			echo -e "  jargroup list \t\t\t\tList the stored jar files."
			echo -e "  jargroup create <name> <download-url> \tCreate a new jar group, with a URL for new downloads"
			echo -e "  jargroup delete <name> \t\t\tDelete a jar group"
			echo -e "  jargroup rename <name> <new-name> \t\tRename a jar group"
			echo -e "  jargroup changeurl <name> <download-url> \tChange the download URL for a jar group"
			echo -e "  jargroup getlatest <name> \t\t\tDownload the latest jar file for a jar group"
			echo -e
			echo -e "--Global Commands-----------------------------------------------"
			echo -e "  start \t\t\t\t\tStarts all active servers"
			echo -e "  stop [now]\t\t\t\t\tStops all running servers"
			echo -e "  restart [now]\t\t\t\t\tRestarts all active servers"
			;;
		"")
			echo "No such command see: $0 help"
			;;
		*)	
			if [[ "$1" == "all" ]] || [[ -e "$SERVER_STORAGE_PATH/$1" ]]; then
				
				local id=$(server_get_id "$1")
				
				case "$2" in
					start)
						server_start $id
						;;
					stop)
						if server_is_running $id; then
						    if [[ $3 != "now" ]]; then
								# Change the state of the script
								STOP_COUNTDOWN[$id]="true"
								
							    server_eval $id "say ${server_stop_message[$id]}"
							    echo "Issued the warning \"${server_stop_message[$id]}\" to players."
								
								echo -n "Shutting down... "
								
								for ((i=${server_stop_delay[$id]}; i>0; i--)); do
									tput sc # Save cursor position
									echo -n "in $i seconds."
									sleep 1
									
									tput rc # Restore cursor to position of last `sc'
									tput el # Clear to end of line
								done
								
								echo -e "Now."
							fi
							
							server_stop $id
						else
						    echo "Server \"${server_name[$id]}\" was not running."
						fi
						;;
					restart)
						if server_is_running $id && [[ $3 != "now" ]]; then
							# Change the state of the script
							RESTART_COUNTDOWN[$id]="true"
							
							server_eval $id "say ${server_restart_message[$id]}"
							echo "Issued the warning \"${server_restart_message[$id]}\" to players."
							
							echo -n "Restarting... "
							
							for ((i=${server_restart_delay[$id]}; i>0; i--)); do
								tput sc # Save cursor position
								echo -n "in $i seconds."
								sleep 1
								
								tput rc # Restore cursor to position of last `sc'
								tput el # Clear to end of line
							done
							
							echo -e "Now."
						fi
							
						server_restart $id	
						;;
					status)
						if server_is_running $1; then
							echo "Server \"${server_name[$id]}\" is running."
						else
							echo "Server \"${server_name[$id]}\" is stopped."
						fi
						;;
					connected)
						;;
					worlds)
						case "$3" in
							list)
								server_worlds_list $id
								;;
							load)
								server_ensure_links $id
								;;
							ram)
								if [ -z "$4" ]; then
									echo "Invalid command."
								else
									world_id=$(server_world_get_id $id "$4")
									
									if [ ! -z $world_id ]; then
										world_toggle_ramdisk_state $world_id
									else
										echo "Server \"${server_name[$id]}\" has no world with that name."
									fi
								fi
								;;
							toram)
								;;
							todisk)
								;;
							backup)
								;;
							*)
								echo "Invalid command."
								;;
						esac
						;;
					logroll)
						;;
					backup)
						;;
					whitelist|wl)
						;;
					blacklist|bl)
						;;
					operator|op)
						;;
					gamemode|gm)
						;;
					kick)
						;;
					say)
						;;
					"time")
						;;
					toggledownfall)
						;;
					save)
						;;
					cmd)
						;;
					cmdlog)
						;;
				esac
			else
				echo "No server with that name."
			fi
			;;
	esac
}


### Start point

main "$@"
exit 0
